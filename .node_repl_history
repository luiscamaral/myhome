let queryUtil = require('./queryUtil.js').queryUtil
import { queryUtil } from './queryUtil.js'
let queryUtilModule = require('./queryUtil.js')
queryUtil = require('./queryUtil.js')
(queryUtil))
console.log(JSON.stringify
queryUtil.queryUtil
queryUtil = require('./queryUtil.js')
queryUtil = require('./queryUtils.js')
import('./queryUtil.js').then(module => { queryUtil = module.queryUtil })
import('queryUtil').then(module => { queryUtil = module.queryUtil })
let queryUtil
import('queryUTil').then(module => { queryUtil = module.queryUtil })
import { queryUtil } from 'queryUtil'
const $ = require( "jquery" )( window );
const { window } = new JSDOM( "" );
const { JSDOM } = require( "jsdom" );
const jquery = require( "jquery" )( window );
const $ = require( "jquery" )( window );
const { window } = new JSDOM( "" );
const { JSDOM } = require( "jsdom" );
var $ = require( "jquery" );
let jquery = require('jquery')
import jquery
typeof a
let a = []
a
a.ComputeStateYield(2, 2)
a.ComputeStateYield(2, 1)
a.ComputeStateYield(1, 1)
a
var a = Player({name: "Pedro"})
}
    return self
    }
        ...player,
        ...s,
        },
            )
                }
                    }
                        justiceSystemYield: justiceSystemYield,
                        incomeTaxesYield: incomeTaxesYield,
                        salesTaxesYield: salesTaxesYield,
                        customTaxesYield: customTaxesYield,
                    stateYield: {
                {
            return (
            let justiceSystemYield = ( self.finance.justiceLevel * 300 - 500 ) * self.nobleTitle
            incomeTaxesYield = Math.floor( Math.abs(2 * incomeTaxesYield * self.finance.incomeTaxes / 100))
            salesTaxesYield = Math.floor( 25 * salesTaxesYield * self.finance.salesTaxes / 100)
            customTaxesYield = Math.floor(5 * customTaxesYield * self.finance.customsTaxes / 100)
            )
                ( luckyNumber / 100 )
                (10 * self.finance.justiceLevel * self.population.nobles) *
                gameLevel * 20 +
                self.population.nobles * 250 +
            let incomeTaxesYield = (
            ) / 2
                (luckyNumber / 100) * (5 - self.finance.justiceLevel)
                    gameLevel * 10) *
                    self.population.merchants * 75 +
                (self.population.nobles * 50 +
            let salesTaxesYield = (
            )
                (luckyNumber / 100) + gameLevel * 20
                    self.population.merchants * 10) *
                    self.population.clerics * 35 +
                (self.population.nobles * 90 +
            let customTaxesYield = (
            luckyNumber *= 0.5
        ComputeStateYield: (luckyNumber, gameLevel) => {
        },
            markets: 0,
            cathedrals: 0,
            palaces: 0,
            mills: 0,
        investments: {
        },
            justiceLevel: 2,
            incomeTaxes: 0.05,
            salesTaxes: 0.1,
            customsTaxes: 0.25,
        finance: {
        },
            grainsReserve: 5000,
            landExtension: 10000,
            cash: 1000,
        economy: {
        },
            soldiers: 25,
            clerics: 5,
            nobles: 4,
            merchants: 25,
            servants: 2000,
        population: {
        minAgeExpectation: Math.random() * 15,
        nobleTitle: 1,
    self = {
    let s = this
const Player = player => {
import { $BM } from 'common/objects'
translatedQuestions.questions = { {type: "translated"}, {} }
translatedQuestions.questions = { {type: "translated"} }
translatedQuestions.questions[0] = { type: "translated" }
console.log(translatedQuestions)
translatedQuestions[0] = { type: "translated" }
let translatedQuestions = {}
});
log(function() {
}
a()
function log(a) {
});
console.log('hi');
log(function() {
{);
console.log('hi');
log(function() {
console.log(person)
person["lastname"] = "Doe"
person["firstname"] = "Tony"
var person = new Object()
console.log(0xFFFFAAAAFFFFBBBBFn)
decodeFixed64BufferToBigInt(a2) === 0xFFFFAAAAFFFFBBBBFn
decodeFixed64BufferToBigInt(a2)
decodeFixed64BufferToBigInt(a1)
a2=encodeFixed64Buffer(0xFFFFAAAAFFFFBBBBFn)
a1=encodeFixed64Buffer('0xFFFFAAAAFFFFBBBBF')
encodeFixed64Buffer(123456n)
encodeFixed64Buffer('123456')
decodeFixed64BufferToBigInt(b)
}
  return bVal;
  }
    bVal |= BigInt(buffer[i]) << (i * 8n);
  for(let i = 1n; i < 8n; i++) {  // loop 8 bytes (64 bits)
  var bVal = BigInt(buffer[0]);
function decodeFixed64BufferToBigInt(buffer) {
decodeFixed64BufferToBigInt(b)
}
  return bVal;
  }
    bVal |= BigInt(buffer[i]) << (i * 8n);
  for(let i=1; i<8; i++) {  // loop 8 bytes (64 bits)
  var bVal = BigInt(buffer[0]);
function decodeFixed64BufferToBigInt(buffer) {
b
b = encodeFixed64Buffer(123456)
encodeFixed64Buffer(123456)
}
  return buffer;
  }
    bVal >>= 8n;  // shift byte to the right
    buffer.writeUInt8(byte, i); // add byte to the buffer
    let byte = Number(bVal & 0xFFn); // get less significant byte
  for(let i = 0; i < 8; i++) {  // loop 8 bytes (64 bits)
  const buffer = Buffer.alloc(8); // allocate 8 bytes (64-bits)
  }
      throw `Invalid value type for conversion (${typeof val}). Please use Number or BigInt.`;
    default:
      break;
      bVal = val;
    case 'bigint':
      break;
      bVal = BigInt(val);
    case 'number':
      break;
      bVal = BigInt(val);
      }
        throw `Invalid string value for conversion. Please use Number or BigInt.`;
      if (isNaN(val)) {
    case 'string':
  switch (typeof val) {
  var bVal = 0n;
function encodeFixed64Buffer(val) {
// Throw error if not valid.
// Encode Fixed64 from convertible string value, number or BigInt.
BI
var BI=BigInt('1091827349817234971239487120394871023984710293874012938741029387410293847102938470987')
'9007199254740991'.length
lenght('9007199254740991')
len('9007199254740991')
Number.MAX_SAFE_INTEGER
isNaN('1091827349817234971239487120394871023984710293874012938741029387410293847102938470987')
isNaN('1000i')
isNaN('1000s')
isNaN('1000')
typeof bi
var bi=BigInt(1000)
typeof s
s
var s = '02020'
typeof val == 'number'
typeof val
var val=1
b.length
b.length()
b.len()
b.size()
Buffer.isBuffer(b)
b
var b = nowAsFixed64Buffer()
}
  return buffer;
  }
    nowNanos >>= 8n;  // shift byte to the right
    buffer.writeUInt8(byte, i); // add byte to the buffer
    let byte = Number(nowNanos & 0xFFn); // get less significant byte
  for(let i=0; i<8; i++) {  // loop 8 bytes (64 bits)
  let nowNanos = BigInt(nowMicro) * 1000n;  // convert time to a BigInt nanoseconds
  const nowMicro = Math.floor(new Date().getTime() * 1000); // get time in microseconds
  const buffer = Buffer.alloc(8); // allocate 8 bytes (64-bits)
function nowAsFixed64Buffer() {
a
a.neg()
a.neg
a.pow(53)
a
var a = bigint(200)
const bigint = require("big-int")
const big-int = require("big-int")
import 'big-int'
BigInt(2).pow(53)
2n.pow(53)
var i=Math.pow(2n, 64n)
i
var i=Math.pow(2, 64)
i
var i=Math.pow(2, 53)
i
var i=Math.pow(2, 53) - 1
max
var max=Number.MAX_SAFE_INTEGER
typeof nowAsFixed64Buffer()
nowAsFixed64Buffer()
}
  return buffer;
  }
    nowNanos >>= 8n;
    buffer.writeUInt8(byte, i);
    let byte = Number(nowNanos & 0xFFn);
  for(let i=0; i<8; i++) {
  // loop 8 bytes (64 bits)
  let nowNanos = BigInt(nowMicro) * 1000n;
  const nowMicro = Math.floor(new Date().getTime() * 1000);
  const buffer = Buffer.alloc(8);
function nowAsFixed64Buffer() {
nowAsFixed64Buffer()
}
  return buffer;
  }
    nowNanos >>= 8n;
    buffer.writeUInt8(byte, i);
    let byte = Number(nowNanos & 0xFFn);
  for(let i=0; i<8; i++) {
  // loop 8 bytes (64 bits)
  let nowNanos = _nanoseconds();
  }
    return BigInt(loadMs).times(1e6).add(BigInt(diffNs[0]).times(1e9).plus(diffNs[1])).toString();
    let diffNs = process.hrtime(loadNs);
  function _nanoseconds() {
  const loadMs = new Date().getTime();
  const loadNs = process.hrtime();
  const buffer = Buffer.alloc(8);
function nowAsFixed64Buffer() {
nowAsFixed64Buffer()
}
  return buffer;
  }
    nowNanos >>= 8n;
    buffer.writeUInt8(byte, i);
    let byte = Number(nowNanos & 0xFFn);
  for(let i=0; i<8; i++) {
  // loop 8 bytes (64 bits)
  let nowNanos = BigInt(nowMicro) * 1000n;
  const nowMicro = Math.floor((performance.now() + performance.timeOrigin) * 1000);
  const buffer = Buffer.alloc(8);
function nowAsFixed64Buffer() {
nowAsFixed64Buffer()
}
  return buffer;
  }
    nowNanos >>= 8n;
    buffer.writeUInt8(byte, i);
    let byte = Number(nowNanos & 0xFFn);
  for(let i=0; i<8; i++) {
  // loop 8 bytes (64 bits)
  let nowNanos = BigInt(nowMicro * 1000n);
  const nowMicro = Math.floor((performance.now() + performance.timeOrigin) * 1000);
  const buffer = Buffer.alloc(8);
function nowAsFixed64Buffer() {
performance.now() + performance.timeOrigin * 1000
performance.now() + performance.timeOrigin * 1000000
nowAsFixed64Buffer()
}
  return buffer;
  }
    nowNanos >>= 8n;
    buffer.writeUInt8(byte, i);
    let byte = Number(nowNanos & 0xFFn);
  for(let i=0; i<8; i++) {
  // loop 8 bytes (64 bits)
  let nowNanos = BigInt( Math.floor(performance.now() + performance.timeOrigin * BigInt(1000000)));
  const buffer = Buffer.alloc(8);
function nowAsFixed64Buffer() {
nowAsFixed64Buffer()
}
  return buffer;
  }
    nowNanos >>= 8n;
    buffer.writeUInt8(byte, i);
    let byte = Number(nowNanos & 0xFFn);
  for(let i=0; i<8; i++) {
  // loop 8 bytes (64 bits)
  let nowNanos = BigInt( Math.floor(performance.now() + performance.timeOrigin * 1000000n));
  const buffer = Buffer.alloc(8);
function nowAsFixed64Buffer() {
nowAsFixed64Buffer()
}
  return buffer;
  }
    nowNanos >>= 8n;
    buffer.writeUInt8(byte, i);
    let byte = Number(nowNanos & 0xFFn);
  for(let i=0; i<8; i++) {
  // loop 8 bytes (64 bits)
  let nowNanos = BigInt(performance.now() + performance.timeOrigin) * 1000000n;
  const buffer = Buffer.alloc(8);
function nowAsFixed64Buffer() {
8*8
performance.now() + performance.timeOrigin * 1000000
now()
performance.now() + performance.timeOrigin * 1000000
performance.now() + performance.timeOrigin
performance.now()
now()*1000000 + getNanoSecTime()
now()
getNanoSecTime()
}
  return hrTime[0] * 1000000000 + hrTime[1];
  var hrTime = process.hrtime();
function getNanoSecTime() {
process.htime()
window.performance.now()
now()
fbig(BigInt(255))
var fbig = (n,k=16) => k ? [(x = n & 0xFFn) >> 4 && '' && console.log(x)] + x.toString(16) + f(n>>8n,k-1) : '';
toFixed64Buffer(100n)
}
return x.toString(16) + f(n>>8, k-1);
x = n & 0xFFn;
if (k) {
function toFixed64Buffer(n,k=16) {
fbig(BigInt(255))
var fbig = (n,k=16) => k ? [(x = n & 0xFFn) >> 4 && '' && console.log(x)] + x.toString(16) + f(n>>8,k-1) : '';
fbig(BigInt(255))
var fbig = (n=0n,k=16) => k ? [(x = BigInt(n & 0xFFn)) >> 4 && '' && console.log(x)] + x.toString(16) + f(n>>8,k-1) : '';
fbig(BigInt(255))
var fbig = (n=0n,k=16) => k ? [(x = BigInt(n & 0xFFn)) >> 4 && ''] + x.toString(16) + f(n>>8,k-1) : '';
fbig(BigInt(255))
var fbig=(n=0n,k=16)=>k?[(x=n&0xFFn)>>4&&'']+x.toString(16)+f(n>>8,k-1):'';
fbig(BigInt(255))
var fbig=(n,k=16)=>k?[(x=n&0xFFn)>>4&&'']+x.toString(16)+f(BigInt(n)>>8,k-1):'';
fbig(BigInt(255))
var fbig=(n,k=16)=>k?[(x=n&0xFFn)>>4&&'']+x.toString(16)+f(n>>8,k-1):'';
f(BigInt(255))
f(255)
const f=(n,k=16)=>k?[(x=n&0xFF)>>4&&'']+x.toString(16)+f(n>>8,k-1):'';
8*8
now() * 1000000
Number.MAX_SAFE_INTEGER.toString(16)
Number.MAX_SAFE_INTEGER
let nb = Buffer.from(nowns.toString(16), "hex")
let nb = Buffer(nowns.toString(16), "hex")
nowns.toString(16)
nowns = now() * 1000000
0x002fbe3100000000
ox002fbe3100000000
0xpbTime=002fbe3100000000
0x00d3133900000000
buf
buf.writeUInt32LE(high, 4)
buf.writeUInt32LE(low, 0)
buf.writeUInt32LE(lo, 0)
high
let high=st & 0xFFFFFFFF00000000;
low=st & 0xFFFFFFFF;
clear
const startTime_ = BigInt(now()) * BigInt(1000000);
BigInt(0)
st.toString(16)
st
typeof st
st>>>0
st>>>16
st>>>32
st
high=(st>>>32) & 0xFFFFFFFF;
low=st & 0xFFFFFFFF;
L=st & 0xFFFFFFFF;
st & 0xFFFFFFFF;
L = st & 0xFFFFFFFF;
let L = st & 0xFFFFFFFF;
st
let st = now() * 1000000
let L = startTime_ & 0xFFFFFFFF;
const startTimeL_ = startTime_ & 0xFFFFFFFF;
const startTimeL_ = startTime & 0xFFFFFFFF;
const startTime_ = BigInt(now()) * BigInt(1000000);
const startTime = BigInt(now()) * BigInt(1000000);
}
    return (new Date).getTime();
function now() {
const startTime = BigInt(now()) * BigInt(1000000);
  pbTime.writeUInt32LE(startTimeH, 4);
  pbTime.writeUInt32LE(startTimeL, 0);
  const startTimeH = (startTime >>> 32) & 0xFFFFFFFF;
  const startTimeL = startTime & 0xFFFFFFFF;
buf.writeUInt32LE(106, 0)
const _encodings = require('protocol-buffers-encodings')
_encodings.fixed64.encode(106, buf, 0)
console.log(_encodings)
print(_encodings)
_encodings.encode.fixed64(106, buf, 0)
_encodings.fixed64(106, buf, 0)
let buf = Buffer.alloc(8)
let a = _encodings.fixed64(106)
const _encodings = require('protocol-buffers-encodings')
const encodings = require('protocol-buffers-encodings')
const protobuf = require('protocol-buffers')
const encodings = require('protocol-buffers-encoding')
buf = messages.Test.num.encode(10.1)
console.log(messages)
print(messages)
typeof messages
})
  payload: 'hello world'
  num: 42,
buf = messages.Test.encode({
buf = messages.Test.encode(100)
buf = messages.fixed64.encode(100)
buf = messages.fixed64(100)
let buf = messages.fixed64(100)
console.log(typeof buf)
console.log(buf)
let buf = messages.compile
let messages = protobuf(fs.readFileSync('test.proto'))
const protobuf = require('protocol-buffers')
console.log(protobuf().compile);
console.log(protobuf.compile);
console.log(protobuf);
const protobuf = require("protocol-buffers");
exit
const protobuf = require("protocol-buffers");
byte.toString(16)
byte.toString('hex')
byte
let byte = long & 0xff;
long
long = 0xABCDEF
console.log(~hi >>> 0)
console.log(~hi)
hi
let hi=100